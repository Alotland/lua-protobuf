lua-protobuf provides a Lua interface to Google's [Protocol Buffers](http://code.google.com/apis/protocolbuffers/).

# How it Works

lua-protobuf provides a plugin for the _protoc_ compiler (that ships with protocol buffers). This plugin receives your protocol buffer definitions and tells _protoc_ to write out new C files which define bindings that allow your protocol buffer messages to be used in Lua. Protocol buffer message instances are treated as Lua userdata types and all calls in Lua land get proxied to the C++ code also generated by _protoc_.

# What's Missing?

lua-protobuf generates C/C++ code that interfaces with the C API of the reference Lua implementation available at http://www.lua.org/. There are various (implementations)[http://lua-users.org/wiki/LuaImplementations] of Lua and many don't expose the same C API that lua-protobuf utilizes. Therefore, you won't be able to use lua-protobuf with these implementations.

An ideal (in terms of compatibility) Lua protocol buffer implementation would be written in 100% Lua so it could run on all interpreters. However, this would be considerable more work, as all the protocol buffer functionality would need to be ported to Lua.

Some protocol buffer features are absent from the implementation. Consult the Lua API section for details on which.

# Lua API

## Protocol Buffer Support

The following table describes the level of support for protocol buffer message features:
<table>
  <tr><th>Definitions</th><th>Support Level</th></tr>
  <tr><td>Optional Fields</td><td>Full</td></tr>
  <tr><td>Required Fields</td><td>Full</td></tr>
  <tr><td>Repeated Fields</td><td>Planned</td></tr>
  <tr><td>Default Values</td><td>Full</td></tr>
  <tr><td>Enumerations</td><td>Planned</td></tr>
  <tr><td>Nested Types</td><td>Planned</td></tr>
  <tr><td>Groups</td><td>Won't Implement (deprecated)</td></tr>
  <tr><td>Extensions</td><td>Planned</td></tr>
  <tr><td>Nested Extensions</td><td>Unknown Future</td></tr>
  <tr><td>Services</td><td>Planned</td></tr>
  <td><td>Options</td><td>Planned</td></tr>
</table>

The following table describes support for the scalar field types on messages:
<table>
  <tr><th>Type</th><th>Supported?</th><th>Lua Type</th></tr>
  <tr><td>double</td><td>Yes</td><td>number</td></tr>
  <tr><td>float</td><td>Yes</td><td>number</td></tr>
  <tr><td>int32</td><td>Yes</td><td>number</td></tr>
  <tr><td>int64</td><td></td><td></td></tr>
  <tr><td>uint32</td><td>Yes</td><td>number</td></tr>
  <tr><td>uint64</td><td></td><td></td></tr>
  <tr><td>sint32</td><td>Yes</td><td>Number</td></tr>
  <tr><td>sint64</td><td></td><td></td></tr>
  <tr><td>fixed32</td><td>Yes</td><td>number</td></tr>
  <tr><td>fixed64</td><td></td><td></td></tr>
  <tr><td>sfixed32</td><td>Yes</td><td>number</td></tr>
  <tr><td>sfixed64</td><td></td><td></td></tr>
  <tr><td>bool</td><td>Yes</td><td>boolean</td></tr>
  <tr><td>string</td><td>Yes</td><td>string</td></tr>
  <tr><td>bytes</td><td>Yes</td><td>string</td></tr>
</table>

## Message Types

Each protocol buffer message is registered as a valid Lua type. The type name is

    "protobuf." + :package + "." + :message_name

For example, the messages in the following protocol buffer definition:

    package acme.example;

    message msgA {
        optional string name = 1;
    }

    message lua {
        repeated uint32 value = 1;
    }

correspond to the Lua types:

    protobuf.acme.example.msgA
    protobuf.acme.example.lua

## Constructing Messages

From Lua, you can create protocol buffer messages by calling the _new_ function of the Lua message type:

    -- create an empty msgA message from the acme.example package
    msg = protobuf.acme.example.msgA.new()

This is equivalent to calling the C++ constructor with no arguments.

If you have a string containing the serialized content of a message, call the _parse_ function of the Lua message type:

    -- parse message from contents of a variable, serialized
    msg = protobuf.acme.example.msgA.parse(serialized)

## Common Message Instance Functions

Each Lua message type has a handful of common functions:

    -- message in variable 'msg'

    -- obtain serialized value of message, as a string
    serialized = msg:serialize()

    -- clear all fields from message
    msg:clear()

    -- merge another message of this type into this one
    -- will error if the argument is not the same type as this one
    msg::mergefrom(another_message)

## Message Fields

Each message field defines a number of accessor and mutator methods.

The name of these functions is the form:

    :action + "_" + :field

All field labels (_required_, _optional_, _repeated_) have the _clear_ action:

    msg:clear_name()

This function does not return any values.

_required_ and _optional_ fields have the _has_, _get_, and _set_ actions:

    bool = msg:has_name()

    value = msg:get_name()

    msg:set_name(new_value)

_repeated_ fields have the _size_ action, which returns the number of elements:

    size = msg:size_multiple()

## Table Access to Fields

Messages can also be treated as tables. Just set the message field name as the table key.

    value = msg['name']
    msg['name'] = 'new value'

_Repeated_ message fields are themselves tables. However, they are indexed by an integer value, starting from 1, as that is the Lua convention.

    value = msg['value'][1]

## Enumerations

Enumerations are represented as Lua tables. Table keys are the strings which correspond to the enumerated values. Table values are the respective integer values of these keys.

Enumeration type names are assigned differently depending on how the enumeration was defined.

If the enumeration was defined at file/package scope (outside a message), the Lua type name will be:

    :package + "." + :enum

If the enumeration was defined inside a message, its table will be available as a key to that message type's metatable.

Let's take the following .proto file as an example:

    package acme;

    enum Color {
        RED = 0;
        GREEN = 1;
        BLUE = 2;
    }

    message Car {
        optional Color color = 1;
    }

    message Sign {
        enum Shape {
            SQUARE = 1;
            ROUND = 2;
        }
        optional Shape shape = 1;
    }

Here is how you would interact with the enumerations:

    car = protobuf.acme.Car.new()
    car.set_color(acme.Color['GREEN'])
    color = car.get_color()

    sign = protobuf.acme.Sign.new()
    sign.set_shape(protobuf.acme.Sign['Shape']['SQUARE'])

# C API

This section documents how to use the C API.

## Registering Lua Libraries

In order to use protocol buffer message types from a Lua state, you need to register them. Each produced C++ header file contains functions whose name ends with _open()_. There exists one open function for each message type and one function for each package. The package open function simply calls all the message functions in that file.

Taking the .proto file from above having the _acme.example_ package, we would have the following functions:

    lua_protobuf_acme_example_open(); -- package 'acme.example'
    lua_protobuf_acme_example_msgA_open(); -- message 'msgA'
    lua_protobuf_acme_example_lua_open();  -- message 'lua'

When you create Lua interpreters, just call the appropriate function(s).

    lua_State *L = luaL_newstate();
    lua_protobuf_acme_example_open(L);
    // all messages from 'acme.example' now available to the interpreter

## Pushing Messages to Lua

It is possible to push messages created in C/C++ to the Lua stack. Each protocol buffer message has a number of functions which can be used for this.

The _pushcopy()_ function will push a _copy_ of a message instance. The copy is owned by Lua and garbage collected when it is no longer used. Since it is a copy, changes made in Lua will not be reflected in the calling program and vice-verse. To receive modifications to the changed message, you will need to pull the message out of Lua.

    ::acme::example::msgA msg = ::acme::example::msgA();
    msg->set_name("my name");

    lua_State *L = luaL_newstate();
    lua_protobuf_acme_example_open(L);
    lua_protobuf_acme_example_msgaA_pushcopy(L, msg);

    // assign the pushed message to the "msg" global variable
    lua_setglobal(L, "msg");


The _pushreference()_ function will push a reference of a message instance (i.e. a pointer). This allows changes in Lua to be reflected in the calling application and vice-versa. It is also faster, since we don't need to copy the message. However, with power comes responsibility. When you push a reference, it is not clear whether the caller or Lua _owns_ the backing memory. To alleviate matters, this function takes optional arguments which can be used to define a function to be called just before Lua garbage collects the object. The return value of this callback tells Lua whether to free the memory. If no function is passed, Lua assumes the caller will free the memory (since the caller has a longer lifetime than Lua itself).

    int msg_gc_notify(::google::protobuf::Message *msg, void *data)
    {
        // do stuff with passed data and determine if you want the message deleted

        if (want_lua_to_free) {
            return 1;
        }
        else {
            return 0;
        }
    }

    // you almost always want to use _new_ otherwise you have greater risk of
    // variable falling out of scope and being destroyed
    ::acme::example::msgA *msg = new ::acme::example::msgA();

    int *ref_count = new ref_count;
    *ref_count = 1;

    lua_protobuf_acme_example_msgA_pushreference(L, msg_gc_notify, (void *)ref_count);

    msg->set_name("some name"); // reflected in Lua immediately

No locking on the object is performed in the Lua code, so it is the caller's responsibility to deal with things like thread safety.